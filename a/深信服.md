深信服

一面

+ 项目

+ 数组底层

+ 结合二者的优势用数组和链表设计数据结构（不会）（哈希表...）

  ![image-20210917104543696](https://gitee.com/ahrunio/pic-go-image-hosting-service/raw/master/img/image-20210917104543696.png)

+ 红黑树（不会）

+ void占几字节，void*占几字节

+ 有多个基类的派生类有几个虚函数表（有几个基类就有几个虚函数表）

+ 了解哪些哈希散列函数（只知道取模）

  几种常见的哈希函数（散列函数）构造方法

  - 直接定址法 
    - 取关键字或关键字的某个线性函数值为散列地址。
    - 即 H(key) = key 或 H(key) = a*key + b，其中a和b为常数。
    - 比如![这里写图片描述](https://img-blog.csdn.net/20161026171706654)
  - 除留余数法 
    - 取关键字被某个不大于散列表长度 m 的数 p 求余，得到的作为散列地址。
    - 即 H(key) = key % p, p < m。 
    - 比如![这里写图片描述](https://img-blog.csdn.net/20161026171807417)
  - 数字分析法 
    - 当关键字的位数大于地址的位数，对关键字的各位分布进行分析，选出分布均匀的任意几位作为散列地址。
    - 仅适用于所有关键字都已知的情况下，根据实际应用确定要选取的部分，尽量避免发生冲突。
    - 比如 ![这里写图片描述](https://img-blog.csdn.net/20161026172017748)
  - 平方取中法 
    - 先计算出关键字值的平方，然后取平方值中间几位作为散列地址。
    - 随机分布的关键字，得到的散列地址也是随机分布的。
    - 比如 ![这里写图片描述](https://img-blog.csdn.net/20161026171618181)
  - 折叠法（叠加法） 
    - 将关键字分为位数相同的几部分，然后取这几部分的叠加和（舍去进位）作为散列地址。
    - 用于关键字位数较多，并且关键字中每一位上数字分布大致均匀。 
    - 比如 ![这里写图片描述](https://img-blog.csdn.net/20161026173032699)
  - 随机数法 
    - 选择一个随机函数，把关键字的随机函数值作为它的哈希值。

+ 哈希冲突的解决

  + **链接法（拉链法）**
  + **开放定址法**
    + **双重散列法**

+ 实现memcpy

  ```c++
  void *memcpy(void *dst, const void *src, unsigned int n)
  {
       if((src==nullptr)||(dst==nullptr)){
         return ;
       }
       while(n--){
         *dst++=*src++;
       }
     	 return dst;
   }
  ```

  

+ 二分查找